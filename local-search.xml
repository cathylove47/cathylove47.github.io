<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>论文的一些前置问题</title>
    <link href="/2025/11/21/%E8%AE%BA%E6%96%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%89%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    <url>/2025/11/21/%E8%AE%BA%E6%96%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%89%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-序言"><a href="#1-序言" class="headerlink" title="1. 序言"></a>1. 序言</h1><p>MEDGS 利用 VeGaS（Gaussian Splatting 的时空变体）在短轴 MRI 切片上进行层间插值，构成了一个合理的基线方法。本文梳理 VeGaS 与 MedGS 的核心思想与关键差异，并提出若干改进方向。</p><h2 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2. 相关工作"></a>2. 相关工作</h2><h3 id="2-1-VeGaS：时空体积中的-Folded-Gaussian"><a href="#2-1-VeGaS：时空体积中的-Folded-Gaussian" class="headerlink" title="2.1 VeGaS：时空体积中的 Folded Gaussian"></a>2.1 VeGaS：时空体积中的 Folded Gaussian</h3><p>普通 3DGS 将三维空间 $(x, y, z)$ 中的场景表示为高斯体素；<strong>VeGaS</strong> 面向二维视频，将视频看作随时间 $t$ 变化的图像序列 $(x, y, t)$，并在**空间—时间体积（Space–Time Volume）**中建模：</p><ul><li><strong>X&#x2F;Y 轴</strong>对应图像的宽&#x2F;高；<strong>Z 轴</strong>对应时间。</li><li>为适配非直线运动轨迹，引入<strong>Folded Gaussian</strong>（折叠高斯分布），通过多项式函数使高斯体在时间维度发生<strong>非线性弯曲</strong>。</li><li>在渲染特定帧时，对弯曲的高斯管进行<strong>条件切片（conditioning）</strong>，得到与该帧对应的 2D 高斯截面。</li></ul><p>VeGaS 的处理痛点与改进：</p><ul><li>传统椭球体是“直的”，难以对齐视频中<strong>弧线运动</strong>（如挥手轨迹）。</li><li>Folded Gaussian 允许“把直的高斯管掰弯”，更好贴合真实运动路径，从而减少重影与形变依赖。</li></ul><p><strong>流程概览</strong></p><ol><li>输入：普通 2D 视频（无需多视角）。</li><li>初始化：在时空体积中撒入高斯体。</li><li>优化：更新位置、颜色与折叠参数，以与观测帧的重建误差（loss）对齐。</li></ol><h3 id="2-2-MedGS：将时间维度映射为层厚维度"><a href="#2-2-MedGS：将时间维度映射为层厚维度" class="headerlink" title="2.2 MedGS：将时间维度映射为层厚维度"></a>2.2 MedGS：将时间维度映射为层厚维度</h3><p>VeGaS 处理的是 $(x, y, t)$；而医学 MRI 是 $(x, y, z)$。在 <strong>MedGS</strong> 中：</p><ul><li>将第 $i$ 张切片视作视频的第 $i$ 帧训练，网络“以为”在拟合动画，实则在拟合<strong>静态 3D 结构</strong>。</li><li>渲染管线关键差异：<ul><li><strong>正交投影（Orthographic Projection）</strong>：取消透视，匹配医学扫描的平行射线特性。</li><li><strong>条件切片（Conditional Slicing）</strong>：训练第 $k$ 张切片（对应某一层位置）时，仅激活并渲染该层附近的高斯体，等价于“数字手术刀”在相应层位做剖切并与观测切片对齐。</li></ul></li></ul><blockquote><p>MRI 通常只有约 20 层，属于<strong>稀疏采样</strong>。直接堆叠会在层间产生空隙，信息丢失。MedGS 借鉴 VeGaS 的折叠高斯，在层间进行<strong>非线性插值</strong>，实现几何一致性的“超分辨率”重建。</p></blockquote><h3 id="2-3-线性插值-vs-3DGS-MedGS"><a href="#2-3-线性插值-vs-3DGS-MedGS" class="headerlink" title="2.3 线性插值 vs 3DGS&#x2F;MedGS"></a>2.3 线性插值 vs 3DGS&#x2F;MedGS</h3><table><thead><tr><th align="left">对比维度</th><th align="left">线性插值（Linear Interpolation）</th><th align="left">3DGS &#x2F; MedGS</th></tr></thead><tbody><tr><td align="left">处理逻辑</td><td align="left">像素级线性混合</td><td align="left">几何拟合，用 3D 形状逼近数据</td></tr><tr><td align="left">斜向结构</td><td align="left">易重影，结构断裂</td><td align="left">自动对齐，保持管状&#x2F;块状连续性</td></tr><tr><td align="left">层间空隙</td><td align="left">模糊过渡，细节丢失</td><td align="left">椭球体填充，边缘更清晰</td></tr><tr><td align="left">数据依赖</td><td align="left">对采样率极度敏感</td><td align="left">对稀疏数据更鲁棒</td></tr></tbody></table><p><strong>结论</strong><br>当 MRI 切片极其密集时，线性插值足够快速与实用；但在仅 <strong>20 层</strong>的稀疏场景中，线性插值会出现<strong>层间断裂</strong>与<strong>阶梯效应</strong>。3DGS 依赖<strong>几何连续性假设</strong>进行体素拟合，更符合解剖结构的连续性，是更合理的重建途径。</p><h2 id="3-展望与改进方向"><a href="#3-展望与改进方向" class="headerlink" title="3. 展望与改进方向"></a>3. 展望与改进方向</h2><ol><li><strong>长轴 LAX 作为几何约束</strong>：在损失函数中引入与 LAX 视图的一致性约束（如投影一致性、结构先验），提升跨层几何对齐。</li><li><strong>扩散模型引导</strong>：利用扩散模型提供对体数据的纹理与形状先验，作为正则项或采样引导，提升插值的可感知质量。</li><li><strong>时间维度的引导</strong>：在动态心脏 MRI 中，利用相邻心动周期的对应关系，建立层位与时序的弱监督对齐（例如从 $T_0$ 到 $T_1$ 的层位漂移建模），减少因运动导致的错配。</li></ol><h2 id="4-具体而言"><a href="#4-具体而言" class="headerlink" title="4. 具体而言"></a>4. 具体而言</h2><p>这是一个非常扎实且具有高度可行性的研究切入点。你对 VeGaS 和 MedGS 的剖析很到位：MedGS 本质上是利用高斯泼溅（3DGS）的<strong>连续表达能力</strong>来解决 MRI 的**层间稀疏（z轴分辨率低）**问题。</p><p>针对你提出的三个改进方向，每一个都对应着计算机视觉与医学图像分析交叉领域的关键痛点。以下是具体的实施建议和技术路线图：</p><hr><h3 id="4-1-方向一：长轴-LAX-作为几何约束-Geometric-Constraint"><a href="#4-1-方向一：长轴-LAX-作为几何约束-Geometric-Constraint" class="headerlink" title="4.1 方向一：长轴 LAX 作为几何约束 (Geometric Constraint)"></a>4.1 方向一：长轴 LAX 作为几何约束 (Geometric Constraint)</h3><p>这是<strong>最直接且最有效</strong>的改进点。<br><strong>现状痛点</strong>：仅依靠短轴（SAX）堆叠，层与层之间（z轴方向）是“盲区”，高斯椭球体可能在这些空隙里随意生长，导致形状不准确。<br><strong>核心思想</strong>：长轴切片（LAX，如 2CH、4CH）在空间上垂直或斜交于 SAX 切片，它们恰好穿过了 SAX 的“盲区”。</p><h4 id="4-1-1-具体实施方案："><a href="#4-1-1-具体实施方案：" class="headerlink" title="4.1.1 具体实施方案："></a>4.1.1 具体实施方案：</h4><ol><li><p><strong>统一世界坐标系（关键）：</strong></p><ul><li>MRI 数据的 DICOM Header 里包含了 <code>Image Position (Patient)</code> 和 <code>Image Orientation (Patient)</code>。必须解析这些信息，将 SAX 和 LAX 所有切片统一转换到同一个 3D 世界坐标系中。</li><li><strong>操作</strong>：构建从像素坐标到统一世界坐标的变换矩阵 $T$。</li></ul></li><li><p><strong>多视角训练策略（Multi-view Training）：</strong></p><ul><li>在 3DGS 看来，SAX 是“从下往上”的一组相机视角，而 LAX 只是几个“从侧面看”的稀疏相机视角。</li><li><strong>渲染管线</strong>：在训练迭代中，随机采样一个视角进行渲染。<ul><li>如果是 SAX 切片：像 MedGS 那样，渲染对应的 z-平面。</li><li>如果是 LAX 切片：根据 LAX 的位姿，对 3D 高斯场进行<strong>任意切面渲染</strong>。注意，这里不能用简单的正交投影，需要根据 LAX 切片在 3D 空间中的真实平面方程，对高斯球进行“切片”或投影。</li></ul></li></ul></li><li><p><strong>设计损失函数</strong>：<br>$$ L_{total} &#x3D; L_{SAX} + \lambda \cdot L_{LAX} $$</p><ul><li>$L_{LAX}$ 强制要求高斯场在 LAX 平面上的渲染结果与真实的 LAX MRI 图像一致。这将强力约束层间插值的几何形状，防止高斯球在层间“乱跑”。</li></ul></li></ol><hr><h3 id="4-2-方向二：扩散模型引导-Diffusion-Prior"><a href="#4-2-方向二：扩散模型引导-Diffusion-Prior" class="headerlink" title="4.2 方向二：扩散模型引导 (Diffusion Prior)"></a>4.2 方向二：扩散模型引导 (Diffusion Prior)</h3><p>这是**提升感知质量（Perceptual Quality）**的前沿方向，类似于 DreamFusion 或 Score Jacobian Chaining。<br><strong>现状痛点</strong>：3DGS 在缺失数据的区域倾向于产生平滑或模糊的结果（类似于 L2 Loss 的平均效应），缺乏心脏肌肉的精细纹理。</p><h4 id="4-2-1-具体实施方案："><a href="#4-2-1-具体实施方案：" class="headerlink" title="4.2.1 具体实施方案："></a>4.2.1 具体实施方案：</h4><ol><li><p><strong>训练特定域的 2D 扩散模型（必做）：</strong></p><ul><li>现有的 Stable Diffusion 无法理解心脏 MRI。你需要收集高质量的心脏 MRI 数据集（如 ACDC 或 M&amp;Ms），训练一个 2D Latent Diffusion Model (LDM) 或者微调一个 LoRA。</li><li>目标：输入高斯噪声，能生成逼真的心脏 MRI 切片。</li></ul></li><li><p><strong>SDS (Score Distillation Sampling) 损失：</strong></p><ul><li>在 3DGS 优化过程中，不仅与真实切片做 Loss，还要在**未被采样的层位（插值位置）**进行“幻觉”引导。</li><li><strong>操作</strong>：<ol><li>随机渲染一个虚拟切片（处于两个 SAX 层之间）。</li><li>将渲染图输入冻结的 2D 扩散模型。</li><li>计算 SDS Loss（梯度）：让扩散模型告诉 3DGS，“这个图像看起来不太像心脏，应该往那个方向改”。</li><li>反向传播更新高斯参数。</li></ol></li></ul></li><li><p><strong>替代方案（更简单的做法）：Inpainting 引导</strong></p><ul><li>不使用复杂的 SDS，而是先用扩散模型对稀疏的 SAX 数据集进行 <strong>z轴 Inpainting（补全）</strong>，生成伪真值（Pseudo-Ground Truth），然后用这些伪数据辅助训练 3DGS。这比 SDS 更快，但上限略低。</li></ul></li></ol><hr><h3 id="4-3-方向三：时间维度的引导-Temporal-Guidance-4D"><a href="#4-3-方向三：时间维度的引导-Temporal-Guidance-4D" class="headerlink" title="4.3 方向三：时间维度的引导 (Temporal Guidance &#x2F; 4D)"></a>4.3 方向三：时间维度的引导 (Temporal Guidance &#x2F; 4D)</h3><p>这是心脏 MRI 这种动态数据（Cine-MRI）的<strong>终极形态</strong>。<br><strong>现状痛点</strong>：MedGS 目前主要处理静态或单帧。心脏是跳动的，且 SAX 切片往往存在<strong>层间错位（Slice Misalignment）</strong>——因为不同层是在不同心跳周期采集的，受呼吸运动影响，它们在空间上对不齐。</p><h4 id="4-3-1-具体实施方案："><a href="#4-3-1-具体实施方案：" class="headerlink" title="4.3.1 具体实施方案："></a>4.3.1 具体实施方案：</h4><ol><li><p><strong>Deformable 3DGS (4DGS)：</strong></p><ul><li>不要只重建静态，而是引入<strong>变形场（Deformation Field）</strong>。</li><li><strong>模型设计</strong>：<ul><li>Canonical Space（标准空间）：重建舒张末期（ED）的静态心脏。</li><li>Deformation Network（变形网络）：输入时间 $t$ 和位置 $(x,y,z)$，输出位移 $(\Delta x, \Delta y, \Delta z)$。</li></ul></li><li>这允许模型利用整个心动周期的信息来优化解剖结构。</li></ul></li><li><p><strong>层间对齐（Slice-to-Volume Registration）：</strong></p><ul><li>这是一个具体的医学问题。你可以将高斯体的中心位置设为可优化的参数。</li><li><strong>策略</strong>：允许每个 SAX 切片在 $(x,y)$ 平面上有一个微小的全局偏移量 $\delta_i$。在训练 3DGS 的同时，优化这个 $\delta_i$，使得重建出的 3D 心脏表面最光滑。如果层间没对齐，3DGS 为了拟合数据会产生“台阶状”伪影；对齐后，表面更平滑。</li></ul></li><li><p><strong>时序一致性 Loss：</strong></p><ul><li>心脏运动具有周期性。</li><li>$$ L_{cyclic} &#x3D; || Gaussian(t&#x3D;0) - Gaussian(t&#x3D;T) || $$</li><li>利用相邻帧的光流（Optical Flow）作为监督，约束高斯球的运动轨迹，使其符合生物力学规律（如体积守恒、平滑形变）。</li></ul></li></ol><hr><h2 id="5-总结与建议的优先级"><a href="#5-总结与建议的优先级" class="headerlink" title="5. 总结与建议的优先级"></a>5. 总结与建议的优先级</h2><p>如果这是你的硕士&#x2F;博士课题，建议按以下顺序推进：</p><ol><li><strong>第一阶段（Basline + 几何约束）：</strong> <strong>(优先级最高)</strong><ul><li>先复现 MedGS。</li><li><strong>加入 LAX 约束</strong>。这在工程上最可控，且逻辑上无懈可击（Ground Truth 就在那里，不用白不用）。这能显著解决“层间断裂”问题。</li></ul></li><li><strong>第二阶段（处理运动）：</strong><ul><li>心脏是动的。引入时间 $t$，使用 Deformable 3DGS 框架。解决呼吸造成的层间错位问题，这在医学影像社区（MICCAI等）非常受重视。</li></ul></li><li><strong>第三阶段（纹理增强）：</strong><ul><li>如果有余力，再引入扩散模型进行纹理增强。因为 MRI 本身就是灰度图，结构比纹理更重要，扩散模型可能引入不必要的幻觉（Hallucination），在医学诊断上存在风险，需要谨慎处理。</li></ul></li></ol><p><strong>技术栈提示</strong>：</p><ul><li>代码库参考：<code>gaussian-splatting</code> (官方), <code>diff-gaussian-rasterization</code>。</li><li>医学数据处理：<code>nibabel</code> (读写 NIfTI&#x2F;DICOM), <code>SimpleITK</code>。</li><li>核心难点：写一个支持**任意平面切片（Arbitrary Slicing）**的 Rasterizer 接口，或者在 Python 端通过坐标变换将切片旋转到正交视角再进行 Rasterization。</li></ul><p>祝你的论文顺利！这三个方向结合起来，绝对是一篇高质量的工作。</p><p>这是一个非常好的学习路径。在做 <strong>心脏 MRI 重建（特别是 SAX + LAX 融合）</strong> 时，你面临的核心问题是：<strong>这是一个“少样本（Sparse-view）”且“各向异性（Anisotropic）”的重建问题</strong>。</p><p>现有的 3DGS 如果没有约束，在没有数据的空隙（层间）会产生“棉絮状”的伪影。</p><p>为了帮你更好地设计<strong>几何约束（Geometric Constraints）</strong>，我精选了三类必读文章。它们分别解决了“怎么对齐切片”、“怎么在少视角下约束几何”以及“怎么利用解剖先验”的问题。</p><hr><h3 id="6-1-第一类：医学影像中的切片-体数据重建-Slice-to-Volume-Reconstruction"><a href="#6-1-第一类：医学影像中的切片-体数据重建-Slice-to-Volume-Reconstruction" class="headerlink" title="6.1 第一类：医学影像中的切片-体数据重建 (Slice-to-Volume Reconstruction)"></a>6.1 第一类：医学影像中的切片-体数据重建 (Slice-to-Volume Reconstruction)</h3><p>这类文章是你的<strong>直接参考对象</strong>。虽然它们大多基于 NeRF 或 INR (隐式神经表示)，但思想完全可以迁移到 3DGS。</p><h4 id="6-1-1-NeSVoR-Implicit-Neural-Representation-for-Slice-to-Volume-Reconstruction-in-MRI-MICCAI-2023-IEEE-TMI"><a href="#6-1-1-NeSVoR-Implicit-Neural-Representation-for-Slice-to-Volume-Reconstruction-in-MRI-MICCAI-2023-IEEE-TMI" class="headerlink" title="6.1.1 NeSVoR: Implicit Neural Representation for Slice-to-Volume Reconstruction in MRI (MICCAI 2023 &#x2F; IEEE TMI)"></a>6.1.1 <strong>NeSVoR: Implicit Neural Representation for Slice-to-Volume Reconstruction in MRI</strong> (MICCAI 2023 &#x2F; IEEE TMI)</h4><ul><li><strong>核心思想</strong>：这是目前医学 INR 重建的标杆。它解决的问题和你一模一样：输入是一堆错位的 2D 切片，输出是一个高分辨率 3D 体数据。</li><li><strong>为什么必读</strong>：<ul><li><strong>坐标系处理</strong>：它详细描述了如何处理 DICOM 中的物理坐标，将不同切片映射到统一空间。</li><li><strong>PSF 建模</strong>：它不仅把切片当做一张图，还对 MRI 的**层厚（Slice Profile）**进行了建模（高斯加权采样），这对于 MedGS&#x2F;VeGaS 的改进至关重要。</li></ul></li><li><strong>对你的启发</strong>：学习它是如何定义 <strong>Sampling Strategy</strong> 的。你渲染长轴（LAX）时，不能只渲染一个像素平面，应该渲染一个有厚度的“薄片”来模拟物理 MRI 采集。</li></ul><h4 id="6-1-2-CoNeRF-Controllable-Neural-Radiance-Fields-for-Coronary-Angiography-ICCV-2023"><a href="#6-1-2-CoNeRF-Controllable-Neural-Radiance-Fields-for-Coronary-Angiography-ICCV-2023" class="headerlink" title="6.1.2 CoNeRF: Controllable Neural Radiance Fields for Coronary Angiography (ICCV 2023)"></a>6.1.2 <strong>CoNeRF: Controllable Neural Radiance Fields for Coronary Angiography</strong> (ICCV 2023)</h4><ul><li><strong>核心思想</strong>：虽然是做血管造影（X-ray），但它利用了极少数的视角（2-4个角度）重建 3D 血管。</li><li><strong>几何约束亮点</strong>：引入了 <strong>Mask-based Geometric Constraint</strong>。<ul><li>如果一个 3D 点投影回去不在 2D mask 里，那个位置的密度就应该被压制。</li></ul></li><li><strong>对你的启发</strong>：<strong>Mask Consistency Loss（掩膜一致性损失）</strong>。<ul><li>利用分割网络提取 SAX 和 LAX 的心脏 Mask。</li><li><strong>逻辑</strong>：如果一个高斯球在 SAX 视角看是在心脏里，但在 LAX 视角看跑到了心脏外，那它就是错的。利用两个视角的 Mask 交集（Visual Hull 概念）来剔除层间伪影。</li></ul></li></ul><hr><h3 id="6-2-第二类：少样本视角下的几何正则化-Sparse-View-Regularization"><a href="#6-2-第二类：少样本视角下的几何正则化-Sparse-View-Regularization" class="headerlink" title="6.2 第二类：少样本视角下的几何正则化 (Sparse View Regularization)"></a>6.2 第二类：少样本视角下的几何正则化 (Sparse View Regularization)</h3><p>这类文章源于计算机视觉（CV），专门解决“相机太少，重建崩坏”的问题。</p><h4 id="6-2-1-RegNeRF-Regularizing-Neural-Radiance-Fields-for-View-Synthesis-from-Sparse-Inputs-CVPR-2022"><a href="#6-2-1-RegNeRF-Regularizing-Neural-Radiance-Fields-for-View-Synthesis-from-Sparse-Inputs-CVPR-2022" class="headerlink" title="6.2.1 RegNeRF: Regularizing Neural Radiance Fields for View Synthesis from Sparse Inputs (CVPR 2022)"></a>6.2.1 <strong>RegNeRF: Regularizing Neural Radiance Fields for View Synthesis from Sparse Inputs</strong> (CVPR 2022)</h4><ul><li><strong>地位</strong>：少样本重建的鼻祖级文章。</li><li><strong>几何约束亮点</strong>：<ul><li><strong>Depth Smoothness Loss（深度平滑损失）</strong>：强制未被观测到的视角的深度图是平滑的。</li></ul></li><li><strong>对你的启发</strong>：心脏表面是光滑的。你可以在训练时，随机渲染一些“层间视角”（既不是 SAX 也不是 LAX），然后对渲染出的 <strong>Depth Map（深度图）</strong> 施加平滑约束（如最小化梯度的 TV Loss）。这能防止高斯球在两层之间“炸毛”。</li></ul><h4 id="6-2-2-SparseGS-Real-Time-360°-Sparse-View-Synthesis-using-Gaussian-Splatting-ArXiv-2023"><a href="#6-2-2-SparseGS-Real-Time-360°-Sparse-View-Synthesis-using-Gaussian-Splatting-ArXiv-2023" class="headerlink" title="6.2.2 SparseGS: Real-Time 360° Sparse View Synthesis using Gaussian Splatting (ArXiv 2023)"></a>6.2.2 <strong>SparseGS: Real-Time 360° Sparse View Synthesis using Gaussian Splatting</strong> (ArXiv 2023)</h4><ul><li><strong>核心思想</strong>：将 RegNeRF 的思想搬到了 3DGS 上。</li><li><strong>几何约束亮点</strong>：提出了针对 3DGS 的深度约束和<strong>不透明度（Alpha）裁剪</strong>策略，防止在没有相机的区域出现漂浮物（Floaters）。</li><li><strong>对你的启发</strong>：直接照搬它的 Loss 设计，用于约束你的 SAX 层间插值区域。</li></ul><hr><h3 id="6-3-第三类：更强的几何表达-Surface-aligned-Constraints"><a href="#6-3-第三类：更强的几何表达-Surface-aligned-Constraints" class="headerlink" title="6.3 第三类：更强的几何表达 (Surface-aligned Constraints)"></a>6.3 第三类：更强的几何表达 (Surface-aligned Constraints)</h3><p>普通的 3DGS 是用“雾状”的椭球体拟合，心脏壁可能有“毛边”。如果你想重建出干净的<strong>解剖表面</strong>，这类文章很重要。</p><h4 id="6-3-1-2D-Gaussian-Splatting-for-Geometrically-Accurate-Radiance-Fields-SIGGRAPH-2024"><a href="#6-3-1-2D-Gaussian-Splatting-for-Geometrically-Accurate-Radiance-Fields-SIGGRAPH-2024" class="headerlink" title="6.3.1 2D Gaussian Splatting for Geometrically Accurate Radiance Fields (SIGGRAPH 2024)"></a>6.3.1 <strong>2D Gaussian Splatting for Geometrically Accurate Radiance Fields</strong> (SIGGRAPH 2024)</h4><ul><li><strong>核心思想</strong>：把 3D 椭球（Ellipsoids）拍扁，变成 2D 圆盘（Surfels&#x2F;Disks）。</li><li><strong>为什么推荐</strong>：心脏壁是薄膜状&#x2F;肌肉层结构。用“扁平的圆盘”去贴合心脏表面，比用“胖胖的球”更容易获得平滑的表面法向量，也更容易利用 <strong>法向量一致性（Normal Consistency）</strong> 作为约束。</li><li><strong>对你的启发</strong>：如果在 MedGS 基础版上效果不好，可以考虑把底层的 3D Gaussian 换成 2D Gaussian，利用其法向量与 MRI 灰度梯度的一致性作为 Loss。</li></ul><h4 id="6-3-2-SuGaR-Surface-Aligned-Gaussian-Splatting-for-Efficient-3D-Mesh-Reconstruction-and-High-Quality-Mesh-Rendering-CVPR-2024"><a href="#6-3-2-SuGaR-Surface-Aligned-Gaussian-Splatting-for-Efficient-3D-Mesh-Reconstruction-and-High-Quality-Mesh-Rendering-CVPR-2024" class="headerlink" title="6.3.2 SuGaR: Surface-Aligned Gaussian Splatting for Efficient 3D Mesh Reconstruction and High-Quality Mesh Rendering (CVPR 2024)"></a>6.3.2 <strong>SuGaR: Surface-Aligned Gaussian Splatting for Efficient 3D Mesh Reconstruction and High-Quality Mesh Rendering</strong> (CVPR 2024)</h4><ul><li><strong>核心思想</strong>：强制高斯分布对齐于物体表面。</li><li><strong>几何约束亮点</strong>：引入了一个正则项，惩罚那些位置远离“等值面（Iso-surface）”的高斯体。</li><li><strong>对你的启发</strong>：心脏重建最终往往需要导出 Mesh 做力学分析。SuGaR 的约束方法能让你直接得到干净的 Mesh，而不是一团点云。</li></ul><hr><h2 id="7-总结：给你的“论文阅读与复现”建议"><a href="#7-总结：给你的“论文阅读与复现”建议" class="headerlink" title="7. 总结：给你的“论文阅读与复现”建议"></a>7. 总结：给你的“论文阅读与复现”建议</h2><p>针对你想做的 <strong>“LAX 几何约束”</strong>，建议按以下步骤阅读和实验：</p><ol><li><strong>入门几何关系</strong>：先读 <strong>NeSVoR</strong>。不用复现它的网络，但要弄懂它是怎么把 SAX 和 LAX 的坐标对齐的（World Coordinate Transformation）。</li><li><strong>设计 Loss</strong>：参考 <strong>CoNeRF</strong> 或 <strong>RegNeRF</strong>。<ul><li>设计一个 <strong>Projection Consistency Loss</strong>：</li><li>$L &#x3D; || \text{Render}(LAX) - \text{Image}(LAX) ||_1$</li><li>如果你有 Segmentation Mask，再加上 $L_{mask} &#x3D; || \text{RenderMask} - \text{GT_Mask} ||$。这是最强的几何约束，能瞬间把层间的空隙填对。</li></ul></li><li><strong>进阶优化</strong>：如果发现重建出的心脏表面坑坑洼洼，参考 <strong>SparseGS</strong> 加一个 Depth Smoothness Loss。</li></ol><p>这几篇文章吃透了，你的方法的理论基础（Theoretical Grounding）就会非常扎实。</p>]]></content>
    
    
    
    <tags>
      
      <tag>论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文的构思</title>
    <link href="/2025/11/19/%E8%AE%BA%E6%96%87%E7%9A%84%E6%9E%84%E6%80%9D/"/>
    <url>/2025/11/19/%E8%AE%BA%E6%96%87%E7%9A%84%E6%9E%84%E6%80%9D/</url>
    
    <content type="html"><![CDATA[<p>这是一个非常棒的研究切入点！心脏 MRI 重建（Cardiac MRI Reconstruction）一直是 <strong>MICCAI</strong>（医学影像顶会）的热门赛道。</p><p>你目前的做法是“利用 VEGAS（Gaussian Splatting 的变体）做短轴（SAX）切片的 Z 轴插值&#x2F;超分”。这算是一个不错的 <strong>Baseline</strong>。</p><p>为了发一篇高质量的论文，单纯的插值确实不够，<strong>引入“长轴（LAX）监督”和“扩散模型（Diffusion Prior）”绝对是两个非常有价值的加分项</strong>。</p><p>我们可以把你的工作包装成一个**“多视角一致性 + 生成式先验辅助的 4D 心脏高保真重建”**系统。</p><p>以下我为你构思的三个具体的创新点方案，你可以根据实现的难易程度选择：</p><hr><h3 id="创新点一：引入长轴（LAX）作为“硬几何约束”-Geometric-Constraint"><a href="#创新点一：引入长轴（LAX）作为“硬几何约束”-Geometric-Constraint" class="headerlink" title="创新点一：引入长轴（LAX）作为“硬几何约束” (Geometric Constraint)"></a>创新点一：引入长轴（LAX）作为“硬几何约束” (Geometric Constraint)</h3><p><strong>核心逻辑：</strong> 短轴（SAX）切片虽然多（20张），但在 Z 轴依然是稀疏的。而长轴（LAX）切片虽然少（5张），但它们在空间上与 SAX 是<strong>正交或呈一定角度</strong>的。<br><strong>价值：</strong> 利用 LAX 数据不仅仅是“辅助”，而是构建**“多视角一致性（Cross-view Consistency）”**。这是 3DGS 的强项。</p><ul><li><strong>怎么做（How）：</strong><ol><li><strong>统一坐标系</strong>：首先利用 DICOM 头文件里的位置信息，将 SAX 和 LAX 的切片统一转换到同一个世界坐标系下。</li><li><strong>联合训练</strong>：不要只用 SAX 训练 Gaussian。在训练时，随机采样视角，既包括 SAX 的视角，也包括 LAX 的视角。</li><li><strong>相交区域约束</strong>：在 SAX 和 LAX 图像在空间中相交的区域（Intersection Line），它们的像素值（MRI 强度）理论上应该是一样的。<ul><li>你可以设计一个 <strong>Intersection Loss</strong>：强制 3DGS 在渲染这两个不同视角时，在相交线上的预测值保持一致。</li></ul></li><li><strong>效果</strong>：LAX 切片会像“钉子”一样，把 SAX 插值产生的模糊 Z 轴结构“钉实”，修正心脏壁的几何形状，防止插值出现变形。</li></ol></li></ul><h3 id="创新点二：引入扩散模型作为“软解剖先验”-Anatomical-Prior"><a href="#创新点二：引入扩散模型作为“软解剖先验”-Anatomical-Prior" class="headerlink" title="创新点二：引入扩散模型作为“软解剖先验” (Anatomical Prior)"></a>创新点二：引入扩散模型作为“软解剖先验” (Anatomical Prior)</h3><p><strong>核心逻辑：</strong> 3DGS 善于拟合数据，但在没有数据的空隙（Z轴间隙），它可能会产生伪影。扩散模型（Diffusion Model）“看过”成千上万张心脏 MRI，它知道正常的心脏肌肉纹理是什么样的。<br><strong>价值：</strong> 这是你提到的“Generative”，用于解决<strong>Ill-posed（病态）问题</strong>，即填补缺失的高频细节。</p><ul><li><strong>怎么做（How）：</strong><ul><li><strong>方案 A（2D 先验指导 3D）：</strong> 类似于 <strong>Score Distillation Sampling (SDS)</strong> 的思路，但不需要文本引导。<ol><li>训练一个无条件（Unconditional）或以切片位置为条件的 2D 心脏 MRI Diffusion 模型。</li><li>在优化 3DGS 时，渲染出一个<strong>未见过的切片位置</strong>（插值位置）。</li><li>把这张渲染图喂给 Diffusion 模型，加噪去噪，计算梯度，告诉 3DGS：“你这里生成的纹理不像真实的心脏组织，改一下”。</li></ol></li><li><strong>方案 B（生成伪切片）：</strong> 这是一个更稳妥的“两阶段”方法。<ol><li>先利用 Diffusion 模型（如基于 Latent Diffusion 的 Inpainting 模型），根据相邻的 SAX 切片，<strong>生成</strong>中间缺失的切片。</li><li>将这些生成的切片作为**伪标签（Pseudo-ground truth）**加入到 3DGS 的训练集中。</li><li>这样 3DGS 就不需要自己瞎猜，而是去拟合 Diffusion 生成的高质量解剖结构。</li></ol></li></ul></li></ul><h3 id="创新点三：利用时间维度（Time）做“时空联合超分”-Spatiotemporal-Super-resolution"><a href="#创新点三：利用时间维度（Time）做“时空联合超分”-Spatiotemporal-Super-resolution" class="headerlink" title="创新点三：利用时间维度（Time）做“时空联合超分” (Spatiotemporal Super-resolution)"></a>创新点三：利用时间维度（Time）做“时空联合超分” (Spatiotemporal Super-resolution)</h3><p><strong>核心逻辑：</strong> 你提到数据带有<strong>时间维度</strong>。心脏在跳动，T0 时刻的第 5 层切片，可能在 T1 时刻心脏收缩后，对应的是 T0 时刻第 5.5 层的解剖结构。<br><strong>价值：</strong> 利用运动信息，让不同时间点的信息互补。</p><ul><li><strong>怎么做（How）：</strong><ul><li>使用 <strong>Deformable 3DGS（可变形高斯）</strong>。</li><li>不要对每个时间点单独建模。建立一个<strong>Canonical Space（标准空间）</strong>（比如舒张末期），然后学习一个**变形场（Deformation Field）**来表示心脏的跳动。</li><li><strong>创新点</strong>：当 Gaussian 随时间移动时，它们会“扫过”原本没有数据的空隙。利用这种<strong>时空相关性</strong>，T1 时刻的数据可以帮助重建 T0 时刻缺失的 Z 轴信息。</li></ul></li></ul><hr><h3 id="💡-综合建议：如何组合成一篇好论文？"><a href="#💡-综合建议：如何组合成一篇好论文？" class="headerlink" title="💡 综合建议：如何组合成一篇好论文？"></a>💡 综合建议：如何组合成一篇好论文？</h3><p>我建议你采用 <strong>“3DGS + LAX Constraint + Diffusion Refinement”</strong> 的组合拳。</p><p><strong>论文 Storyline (故事线) 参考：</strong></p><ol><li><strong>Problem</strong>: 现有的心脏 MRI Z轴分辨率低，传统插值模糊，且单纯的生成模型缺乏 3D 一致性。</li><li><strong>Method (你的模型名字，比如 HeartGaussian)</strong>:<ul><li><strong>Base</strong>: 使用 <strong>Deformable 3DGS</strong> 建模动态心脏（利用了时间维度）。</li><li><strong>Contribution 1 (几何)</strong>: 提出 <strong>“Orthogonal Plane Guidance” (正交平面引导)</strong>，利用 5 张 LAX 切片作为稀疏视角监督，锁定心脏的整体几何结构。</li><li><strong>Contribution 2 (纹理)</strong>: 引入 <strong>“Diffusion-based Slice Refinement”</strong>，利用预训练的 2D Diffusion 模型作为正则化项，优化插值区域的纹理细节，使其符合解剖学特征。</li></ul></li><li><strong>Result</strong>: 相比于单纯的插值（Bicubic&#x2F;Spline）和单纯的 3DGS（Vegas），你的方法在 PSNR 上更高（因为有 LAX 修正），且在 LPIPS（感知指标）上更好（因为有 Diffusion 加持）。</li></ol><p><strong>总结：</strong><br>你的想法完全可行！<strong>长轴监督</strong>是必须加的（因为它就在你手里，不用白不用，且非常符合 3DGS 的多视角特性）。<strong>扩散模型</strong>可以作为一个提升画质的模块加入，这样你的论文既有传统的几何约束（Rigorous），又有生成式 AI 的前沿技术（Fancy），非常适合投 MICCAI 或 IEEE TMI。</p><hr><p>这是两个非常具体且关键的问题。只要解决了这两个顾虑，你的论文逻辑就通了。</p><p>我来分两部分回答你：一是<strong>长短轴结合的“含金量”与潜在坑点</strong>，二是<strong>针对你目前的背景，最高效的扩散模型（Diffusion）上手路线</strong>。</p><hr><h3 id="第一部分：长轴（LAX）监督到底强不强？"><a href="#第一部分：长轴（LAX）监督到底强不强？" class="headerlink" title="第一部分：长轴（LAX）监督到底强不强？"></a>第一部分：长轴（LAX）监督到底强不强？</h3><p><strong>结论：非常强，而且是医学影像重建里的“黄金标准”。但有一个前提——配准（Registration）。</strong></p><h4 id="1-为什么强？（从几何角度看）"><a href="#1-为什么强？（从几何角度看）" class="headerlink" title="1. 为什么强？（从几何角度看）"></a>1. 为什么强？（从几何角度看）</h4><p>想象你在切一块面包（心脏）。</p><ul><li><strong>SAX（短轴）</strong>：是你横着切了 20 刀，每一片面包内部很清晰，但两片面包之间（Z轴）是空的，或者是你插值“猜”出来的。</li><li><strong>LAX（长轴）</strong>：是你竖着切了 5 刀。</li><li><strong>关键点</strong>：这 5 刀竖着切下去，会<strong>垂直穿过</strong>你所有的 20 片横切面。</li><li><strong>监督信号</strong>：在长轴和短轴的<strong>交界线</strong>上，像素值必须相等。<ul><li>如果不加长轴：你的插值可能是“平滑但错误”的。</li><li>加了长轴：这 5 个面就像 5 根钢筋，把松散的 SAX 切片“串”起来了。它直接约束了心脏壁在 Z 轴方向的曲率。对于 20 张 SAX 来说，5 张 LAX 提供的交叉约束已经非常密集了。</li></ul></li></ul><h4 id="2-难点与创新机会（Paper的卖点）"><a href="#2-难点与创新机会（Paper的卖点）" class="headerlink" title="2. 难点与创新机会（Paper的卖点）"></a>2. 难点与创新机会（Paper的卖点）</h4><p>你担心的“不强”，通常是因为**“对不齐”**。</p><ul><li><strong>问题</strong>：MRI 扫描 SAX 和 LAX 通常是分次扫描的。病人可能会呼吸、移动，或者心跳周期没完全对上。这会导致 SAX 和 LAX 在空间上对应不起来（比如长轴显示这里是血池，短轴对应位置却是心肌）。</li><li><strong>如果直接强行监督</strong>：模型会糊，因为它不知道该听谁的。</li><li><strong>你的创新点（Contribution）</strong>：<ul><li><strong>不要假设它们是对齐的</strong>。</li><li>在 3DGS 的训练过程中，加入一个**微小的位姿优化（Pose Refinement）**模块。让 Gaussian 在训练几何结构的同时，自动微调 LAX 切片的 6DoF（位置和旋转），使其与 SAX 数据最吻合。</li><li><strong>写法</strong>：这叫 <em>“Joint Optimization of Geometry and Slice Misalignment”</em>（几何与切片错位的联合优化）。这比单纯用数据监督高级得多，是 MICCAI 很喜欢的点。</li></ul></li></ul><hr><h3 id="第二部分：零基础如何快速上手-Diffusion-并结合到你的论文？"><a href="#第二部分：零基础如何快速上手-Diffusion-并结合到你的论文？" class="headerlink" title="第二部分：零基础如何快速上手 Diffusion 并结合到你的论文？"></a>第二部分：零基础如何快速上手 Diffusion 并结合到你的论文？</h3><p>既然你是为了发论文，<strong>不要去学深奥的数学推导</strong>（什么变分下界、马尔可夫链先放一边）。你需要的是**“能跑通，能生成图，能当正则项用”**。</p><h4 id="学习路线图（预计耗时：1-2周）"><a href="#学习路线图（预计耗时：1-2周）" class="headerlink" title="学习路线图（预计耗时：1-2周）"></a>学习路线图（预计耗时：1-2周）</h4><h4 id="第-1-步：理解核心逻辑（1天）"><a href="#第-1-步：理解核心逻辑（1天）" class="headerlink" title="第 1 步：理解核心逻辑（1天）"></a>第 1 步：理解核心逻辑（1天）</h4><p>不要看公式，看图解。</p><ul><li><strong>核心</strong>：Diffusion 就是一个“去噪器”。给它一张全是噪点的图，它能还原出清晰的心脏图。</li><li><strong>应用</strong>：你的 3DGS 插值出来的切片，可能带有模糊或伪影（这可以被视为一种“噪声”）。你可以用训练好的 Diffusion 模型把这个“模糊切片”修成“清晰切片”。</li></ul><h4 id="第-2-步：跑通代码（3-4天）"><a href="#第-2-步：跑通代码（3-4天）" class="headerlink" title="第 2 步：跑通代码（3-4天）"></a>第 2 步：跑通代码（3-4天）</h4><p>不要自己写模型，使用 <strong>Hugging Face Diffusers</strong> 库，或者医学影像专用的 <strong>MONAI Generative Models</strong>。</p><ul><li><strong>推荐工具</strong>：MONAI (Project MONAI)。它是专门做医学影像 AI 的，里面有现成的 <code>DiffusionModelUNet</code>。</li><li><strong>任务</strong>：<ol><li>把你的 20 张 SAX 和 5 张 LAX 数据整理好（归一化到 0-1）。</li><li>用这些 2D 切片训练一个简单的 <strong>DDPM (Denoising Diffusion Probabilistic Model)</strong>。</li><li>因为你数据量小（如果是单病人数据），模型很容易过拟合，但这对你来说反而是好事（Overfitting to the patient），因为你就是想重建这个特定的病人。</li></ol></li></ul><h4 id="第-3-步：集成到-3DGS（最关键的一步）"><a href="#第-3-步：集成到-3DGS（最关键的一步）" class="headerlink" title="第 3 步：集成到 3DGS（最关键的一步）"></a>第 3 步：集成到 3DGS（最关键的一步）</h4><p>怎么把上面练好的模型加到 3DGS 里？有两种方案，推荐<strong>方案 B</strong>（更简单，易落地）。</p><ul><li><p><strong>方案 A (高难度，类似 DreamFusion&#x2F;SDS)</strong>：</p><ul><li>在 3DGS 训练 loss 里加一项梯度，这需要深入改写 PyTorch 的反向传播，坑很多，容易不收敛。</li></ul></li><li><p><strong>方案 B (低难度，伪标签法 - Pseudo Labeling)</strong>：</p><ul><li><strong>流程</strong>：<ol><li>用你现有的 Vegas&#x2F;插值方法，先生成一个粗糙的密集 Z 轴切片（比如插值出 100 张）。</li><li>把这 100 张粗糙图，扔给你刚训练好的 Diffusion 模型，运行 <strong>“Image-to-Image” (Img2Img)</strong> 模式。</li><li>Diffusion 会把粗糙图“修”得像真的 MRI。</li><li><strong>把修好的图当作 Ground Truth（真值）</strong>，再重新训练一遍 3DGS。</li></ol></li><li><strong>好处</strong>：完全解耦。你不需要改 3DGS 的底层 CUDA 代码，只需要处理图片。</li></ul></li></ul><h3 id="总结你的论文“配方”"><a href="#总结你的论文“配方”" class="headerlink" title="总结你的论文“配方”"></a>总结你的论文“配方”</h3><p>如果你觉得 Diffusion 实在太难啃，我建议你保留 <strong>长轴监督</strong>，并将重心放在 <strong>“解决呼吸运动导致的长短轴未对齐问题”</strong> 上。</p><p><strong>推荐的论文配置（如果不加 Diffusion）：</strong></p><ol><li><strong>Title</strong>: Robust 4D Cardiac Reconstruction via 3D Gaussian Splatting with <strong>Misalignment-Aware</strong> Orthogonal Views.</li><li><strong>Method</strong>:<ul><li><strong>Base</strong>: 4D Gaussian Splatting (处理时间维度).</li><li><strong>Key Module</strong>: Learnable Slice Pose (在训练中自动修正长轴切片的轻微位移).</li><li><strong>Loss</strong>: Orthogonal Consistency Loss (在长短轴交界处强制一致).</li></ul></li></ol><p><strong>推荐的论文配置（如果加 Diffusion）：</strong></p><ol><li><strong>Title</strong>: <strong>Generative</strong> 4D Cardiac MRI Reconstruction: Combining Gaussian Splatting with Diffusion Priors.</li><li><strong>Method</strong>:<ul><li>先用长轴+短轴训练粗糙 3DGS。</li><li>导出插值切片，用 Diffusion 模型进行 <strong>Inpainting&#x2F;Refinement</strong>。</li><li>将 Refine 后的数据回填，微调 3DGS。</li></ul></li></ol><p>我的建议：先做长轴监督（加上位姿修正）。如果效果已经很好（SSIM&#x2F;PSNR 提升明显），其实已经够一篇不错的会议论文了。Diffusion 可以作为锦上添花，如果时间来不及可以不加，或者作为 Future Work。</p><hr><h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><ol><li>首先LAX图像和SAX到底是不是完全对齐的，也就是每一帧的切片是否是同一时刻采集的，如果不是完全对齐的，就需要考虑到配准，要把SAX和LAX放到同一个空间里面来</li><li>方法的话可以设置一个3dgs的微小的位姿优化模块，让高斯核在训练几何结构的时候同时自动微调lAX切片的旋转和和平移</li><li></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>写论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vegas</title>
    <link href="/2025/11/19/vegas/"/>
    <url>/2025/11/19/vegas/</url>
    
    <content type="html"><![CDATA[<h3 id="1-核心思路：把“时间”变成“空间”-Time-as-Depth"><a href="#1-核心思路：把“时间”变成“空间”-Time-as-Depth" class="headerlink" title="1. 核心思路：把“时间”变成“空间” (Time as Depth)"></a>1. 核心思路：把“时间”变成“空间” (Time as Depth)</h3><p>普通的 3DGS 是把 $x, y, z$ 三维空间里的物体变成高斯球。<br>而 <strong>VeGaS</strong> 处理的是一段 2D 视频。视频本来是 $(x, y)$ 的图像随时间 $t$ 变化。</p><p>VeGaS 做了一个很有趣的转换：</p><ul><li>它把视频看作一个 <strong>3D 空间-时间体积 (Space-Time Volume)</strong>。</li><li><strong>X 轴 &amp; Y 轴</strong>：还是图像的宽和高。</li><li><strong>Z 轴</strong>：变成了<strong>时间 (Time)</strong>。</li></ul><p>你可以想象把视频的每一帧画面打印出来，像一摞纸一样叠在一起。这就变成了一个长方体。VeGaS 就在这个“长方体”里扔高斯球，用来拟合这摞纸上的像素颜色。</p><h3 id="2-VeGaS-解决的痛点：非线性动态-Non-linear-Dynamics"><a href="#2-VeGaS-解决的痛点：非线性动态-Non-linear-Dynamics" class="headerlink" title="2. VeGaS 解决的痛点：非线性动态 (Non-linear Dynamics)"></a>2. VeGaS 解决的痛点：非线性动态 (Non-linear Dynamics)</h3><p>如果只是简单地把视频叠成 3D 空间，用普通的 3D 高斯球去拟合，会遇到一个大问题：<strong>动作通常不是直线的。</strong></p><ul><li><strong>普通高斯球的局限：</strong> 标准的 3D 高斯球是椭球体，它的形状是线性的（直的）。</li><li><strong>视频里的问题：</strong> 比如视频里一个人在挥手，手的轨迹是<strong>弧线</strong>。如果你用一个长长的直条形椭球去代表这只手在几秒内的轨迹，它根本对不上（手是弯着动的，球是直的）。</li><li><strong>之前的笨办法：</strong> 之前的算法（如 VGR）只能把手切成无数个极短的小球，或者强行用变形场去扭，效果不好且难以编辑。</li></ul><h3 id="3-核心魔法：折叠高斯-Folded-Gaussians"><a href="#3-核心魔法：折叠高斯-Folded-Gaussians" class="headerlink" title="3. 核心魔法：折叠高斯 (Folded-Gaussians)"></a>3. 核心魔法：折叠高斯 (Folded-Gaussians)</h3><p>这是 VeGaS 这篇论文最大的创新点。</p><p>为了解决“动作是弯的，球是直的”这个问题，作者发明了一种新的数学工具——<strong>Folded-Gaussian Distribution（折叠高斯分布）</strong>。</p><ul><li><strong>原理：</strong> 这种新型高斯球不再是死板的椭球。它引入了一个多项式函数，允许高斯球在“时间轴”方向上发生<strong>非线性的弯曲</strong>。</li><li><strong>通俗理解：</strong> 想象你有一根这就好比一根直香肠（普通高斯），现在你可以把它<strong>掰弯</strong>（Folded Gaussian），让它完美贴合视频里那个挥手动作的弧线轨迹。</li><li><strong>条件概率：</strong> 当我们需要渲染某一帧（比如第 5 秒）时，VeGaS 会在这个弯曲的高斯管上“切一刀”（Conditioning），切出来的截面就是一个 2D 的高斯斑点，正好对应那一帧图像里的物体。</li></ul><h3 id="4-VeGaS-的训练与渲染过程"><a href="#4-VeGaS-的训练与渲染过程" class="headerlink" title="4. VeGaS 的训练与渲染过程"></a>4. VeGaS 的训练与渲染过程</h3><h4 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h4><ol><li><strong>输入：</strong> 一段普通的 2D 视频（不需要多视角，就普通手机拍的视频）。</li><li><strong>初始化：</strong> 在这个“视频立方体”里撒入 3D 高斯球。</li><li><strong>优化：</strong><ul><li>调整这些球的位置、颜色。</li><li><strong>关键：</strong> 调整“折叠参数”，让高斯球弯曲，去追踪视频里物体的运动轨迹。</li><li>利用对比原始视频帧的 Loss 来更新参数。</li></ul></li></ol><h4 id="渲染与编辑过程"><a href="#渲染与编辑过程" class="headerlink" title="渲染与编辑过程"></a>渲染与编辑过程</h4><p>VeGaS 的主要目的不是为了“到处看”（像 3D 漫游），而是为了<strong>编辑视频</strong>。</p><ul><li><strong>视频重建：</strong> 在任意时间点 $t$ 切片，都能还原出清晰的图像。</li><li><strong>视频编辑（亮点）：</strong><ul><li>因为视频里的一个物体（比如一只猫）被表示成了一组连贯的“弯曲高斯球”。</li><li>你可以直接选中这组高斯球，进行<strong>移动、缩放、复制</strong>。</li><li><strong>效果：</strong> 你可以在视频里把这只猫变大一倍，或者把猫从左边移到右边，或者复制出两只猫。由于高斯球记录了猫随时间的所有动作，<strong>修改后的猫依然会保持原本的动作连贯性</strong>，看起来非常真实。</li></ul></li></ul><h3 id="5-总结：VeGaS-的意义"><a href="#5-总结：VeGaS-的意义" class="headerlink" title="5. 总结：VeGaS 的意义"></a>5. 总结：VeGaS 的意义</h3><p><strong>VeGaS</strong> 不是用来做 VR 里的 3D 场景漫游的（那是 4DGS 或 Dynamic 3DGS 做的事），它是用来做 <strong>AIGC 视频编辑</strong>的。</p><ul><li><strong>以前的视频编辑：</strong> 想把视频里的人P掉或移动，需要一帧一帧修（Rotoscoping），非常痛苦。</li><li><strong>VeGaS 的编辑：</strong> 把视频变成一堆“有时间属性的球”。想改哪里，直接拖动那些球，整个视频的动作就自动跟着改了。</li></ul><p><strong>一句话概括：</strong><br>VeGaS 是一种利用**“折叠高斯”<strong>技术，将 2D 视频转化为</strong>可编辑的 3D 时空表示**的技术，它让视频内容的修改变得像编辑 PPT 里的图片一样简单。</p><p>这是一个非常敏锐的发现！你把 <strong>MRI（医学图像）</strong> 和 <strong>Video（视频）</strong> 联系起来是非常准确的直觉，因为从数学和数据结构上看，它们本质上是一回事。</p><p>在 MedGS（或者类似的医学 3DGS 论文）中，借鉴 <strong>VeGaS</strong>（或 Video-based 3DGS）的思路是非常自然的。</p><p>让我们来拆解一下 MedGS 是如何“魔改” VeGaS 的原理，把 20 张 MRI 切片变成一个连续的 3D 器官模型的。</p><h3 id="1-核心映射：时间-t-vs-空间-z"><a href="#1-核心映射：时间-t-vs-空间-z" class="headerlink" title="1. 核心映射：时间 $t$ vs. 空间 $z$"></a>1. 核心映射：时间 $t$ vs. 空间 $z$</h3><p>VeGaS 的核心是处理 $(x, y, t)$，而 MRI 数据是 $(x, y, z)$。</p><ul><li><strong>在 VeGaS 中：</strong> 第 3 维度是<strong>时间</strong>。第 1 帧和第 2 帧之间，代表物体“动”了一点点。</li><li><strong>在 MedGS 中：</strong> 第 3 维度是<strong>深度（层）</strong>。第 1 张切片和第 2 张切片之间，代表人体组织结构“变”了一点点。</li></ul><p><strong>魔改的第一步</strong>就是直接把 MRI 的第 $i$ 张切片，当成视频的第 $i$ 帧喂给网络。网络以为它在学一个“变形的动画”，其实它在学一个“静态的 3D 结构”。</p><h3 id="2-渲染方式的魔改：从“拍照”变成“切片”"><a href="#2-渲染方式的魔改：从“拍照”变成“切片”" class="headerlink" title="2. 渲染方式的魔改：从“拍照”变成“切片”"></a>2. 渲染方式的魔改：从“拍照”变成“切片”</h3><p>这是最关键的区别。普通的 3DGS（包括 VeGaS）是模拟<strong>摄像机（Camera）</strong>，有近大远小的透视效果。但 MRI 不需要透视。</p><p>MedGS 对渲染管线做了如下修改：</p><ul><li><strong>原版 VeGaS&#x2F;3DGS：</strong><ul><li>我在 3D 空间放一个摄像机。</li><li>把高斯球投影到屏幕上（Perspective Projection）。</li><li>计算颜色叠加。</li></ul></li><li><strong>魔改后的 MedGS：</strong><ul><li><strong>正交投影 (Orthographic Projection)：</strong> 取消“近大远小”，模拟医学扫描仪的射线平行穿过。</li><li><strong>条件切片 (Conditional Slicing)：</strong><br>当训练第 5 张 PNG（假设它对应 $z&#x3D;10mm$ 处）时，算法<strong>只激活</strong>和渲染 z 轴坐标在 $10mm$ 附近的高斯球。<br>它就像一把<strong>数字手术刀</strong>，只横切这一层，计算这一层截面的颜色，然后跟第 5 张 PNG 去算 Loss。</li></ul></li></ul><h3 id="3-从“运动轨迹”到“组织连续性”"><a href="#3-从“运动轨迹”到“组织连续性”" class="headerlink" title="3. 从“运动轨迹”到“组织连续性”"></a>3. 从“运动轨迹”到“组织连续性”</h3><p>你提到只有 20 张 PNG，这在医学上属于<strong>稀疏采样 (Sparse Sampling)</strong>（通常 MRI 可能需要上百张才清晰）。如果直接堆叠，层与层之间会有很大的缝隙。</p><p>利用 VeGaS 的逻辑，MedGS 实现了<strong>超分辨率（Super-resolution）</strong>：</p><ul><li><strong>VeGaS 的逻辑：</strong> 视频只有 24 帧，但我想要 60 帧。利用高斯球的变形能力，我可以算出第 1.5 帧长什么样（插帧）。</li><li><strong>MedGS 的逻辑：</strong> MRI 只有 20 层（z&#x3D;1, z&#x3D;2…），层间距很大。利用高斯球在空间中的连续分布，我可以渲染出 <strong>z&#x3D;1.5</strong> 处的切片。</li><li><strong>结果：</strong> 哪怕原始数据像“百叶窗”一样有缝隙，训练好的 MedGS 模型能生成一个像“果冻”一样内部完全连续的 3D 器官。医生可以随意查看任意深度的切面，而不仅限于那 20 张原图。</li></ul><h3 id="4-颜色的重新定义"><a href="#4-颜色的重新定义" class="headerlink" title="4. 颜色的重新定义"></a>4. 颜色的重新定义</h3><ul><li><strong>VeGaS：</strong> 优化的是 RGB 颜色（红绿蓝）。</li><li><strong>MedGS：</strong> 优化的是<strong>灰度值</strong>或<strong>辐射密度</strong>。<br>医学图像（如 CT&#x2F;MRI）的像素值不仅是颜色，还代表物理意义（比如 Hounsfield Unit，代表组织密度）。MedGS 会把高斯球的属性从“发光颜色”魔改为“组织密度&#x2F;信号强度”。</li></ul><h3 id="总结：MedGS-到底做了什么？"><a href="#总结：MedGS-到底做了什么？" class="headerlink" title="总结：MedGS 到底做了什么？"></a>总结：MedGS 到底做了什么？</h3><p>它把那 20 张 PNG 不当作“照片”，而是当作 <strong>20 个路标（Checkpoints）</strong>。</p><ol><li><strong>初始化：</strong> 在 3D 空间撒一把高斯球。</li><li><strong>训练：</strong><ul><li>切到 $z&#x3D;1$ 的位置，渲染出一张图，跟第 1 张 PNG 比对，调整高斯球让它们长得像肝脏&#x2F;肿瘤。</li><li>切到 $z&#x3D;2$ 的位置，跟第 2 张 PNG 比对…</li></ul></li><li><strong>魔改点（VeGaS 思想）：</strong><br>它利用高斯球的体积特性，<strong>自动脑补</strong>了第 1 张和第 2 张图片之间没拍到的那些组织结构（就像 VeGaS 脑补帧与帧之间的动作一样）。</li></ol><p>最终，你得到的不只是 20 张图片，而是一个<strong>可任意旋转、任意切片、分辨率无限放大</strong>的 3D 数字人体模型。这就是 3DGS 技术在医学重建上的核心意义。</p><hr><p>这是一个非常棒的质疑！你的直觉很敏锐：<strong>“凭什么3DGS在没数据的空白区域（两张切片之间）瞎猜，会比数学上老实巴交的线性插值（Linear Interpolation）更好？”</strong></p><p>事实上，在早期的NeRF和3DGS研究中，大家也有这个怀疑。但经过实验证明，在医学图像（特别是像MRI&#x2F;CT这种层间距较大的情况）重建上，<strong>3DGS（或基于隐式神经表示的方法）通常完爆线性插值</strong>。</p><p>核心原因在于：<strong>线性插值不懂“结构”，而3DGS自带“几何先验”。</strong></p><p>我们可以通过三个具体的维度来对比：<strong>“斜向结构”、“边缘锐度”和“伪影问题”</strong>。</p><hr><h3 id="1-“斜向结构”难题（最直观的差异）"><a href="#1-“斜向结构”难题（最直观的差异）" class="headerlink" title="1. “斜向结构”难题（最直观的差异）"></a>1. “斜向结构”难题（最直观的差异）</h3><p>假设有一个<strong>血管</strong>，它不是垂直生长的，而是<strong>斜着</strong>穿过人体。</p><ul><li><p><strong>MRI切片情况：</strong></p><ul><li>切片 A（z&#x3D;0）：血管在坐标 (10, 10)。</li><li>切片 B（z&#x3D;1）：血管在坐标 (12, 12)。</li><li><strong>真实情况</strong>：在 z&#x3D;0.5 的中间位置，血管应该在 (11, 11)。</li></ul></li><li><p><strong>线性插值 (Linear Interpolation) 的做法：</strong></p><ul><li>它只会在像素层面对齐。它会把切片A的(10,10)和切片B的(10,10)混合，把切片A的(12,12)和切片B的(12,12)混合。</li><li><strong>结果：</strong> 在 z&#x3D;0.5 处，你会看到<strong>两个半透明的模糊影子</strong>（Ghosting），一个在(10,10)，一个在(12,12)，而真正的中心(11,11)反而是空的或者灰蒙蒙的。</li><li><strong>后果：</strong> 血管断了，变成了两个虚影。</li></ul></li><li><p><strong>3DGS 的做法：</strong></p><ul><li>高斯球是 3D 的椭球体，它可以<strong>旋转</strong>。</li><li>为了同时拟合切片A的(10,10)和切片B的(12,12)，优化算法会自动把一个长条形的高斯球<strong>斜着摆放</strong>。</li><li><strong>结果：</strong> 在 z&#x3D;0.5 处，如果你去切这个高斯球，截面正好就在 (11,11)。</li><li><strong>优势：</strong> 它保留了血管的<strong>连续性和拓扑结构</strong>。它“猜”到了这两点之间应该连着一根管子，而不是两个孤立的点。</li></ul></li></ul><h3 id="2-边缘锐度-Sharpness-vs-模糊"><a href="#2-边缘锐度-Sharpness-vs-模糊" class="headerlink" title="2. 边缘锐度 (Sharpness) vs. 模糊"></a>2. 边缘锐度 (Sharpness) vs. 模糊</h3><ul><li><p><strong>线性插值：</strong></p><ul><li>本质上是一个<strong>低通滤波器</strong>。当你对两张图片进行加权平均时，图像的高频信息（锐利的边缘、纹理）会被抹平。</li><li>重建出来的 3D 模型，侧面看会像是一层层堆叠的阶梯（Staircase artifacts），或者整体像被磨皮了一样糊。</li></ul></li><li><p><strong>3DGS：</strong></p><ul><li>高斯函数本身虽然是平滑的，但多个高斯球叠加可以通过调整 $\alpha$（不透明度）和 Scale（大小）来拟合非常锐利的边缘（Step Function）。</li><li>它不是在混合像素，而是在<strong>拟合边界</strong>。即使在两层切片之间，高斯球定义的边界依然是清晰确定的。</li></ul></li></ul><h3 id="3-3DGS-的“脑补”逻辑：几何先验-Geometric-Priors"><a href="#3-3DGS-的“脑补”逻辑：几何先验-Geometric-Priors" class="headerlink" title="3. 3DGS 的“脑补”逻辑：几何先验 (Geometric Priors)"></a>3. 3DGS 的“脑补”逻辑：几何先验 (Geometric Priors)</h3><p>你担心的“3DGS不适合对空白区域插值”，其实是因为你把它看作是“填空”。但实际上，3DGS 把它看作是**“放置积木”**。</p><ul><li><strong>生物学特性：</strong> 人体组织（器官、肿瘤、血管）在物理上通常是<strong>连续的团块</strong>或<strong>管道</strong>。</li><li><strong>高斯球特性：</strong> 高斯球正好就是<strong>团块状</strong>的。</li><li><strong>原理：</strong> 当你强迫一堆高斯球去适配 z&#x3D;0 和 z&#x3D;1 的切片时，由于高斯球本身有体积（Scale），它的“肚子”填满了 z&#x3D;0 和 z&#x3D;1 之间的空隙。</li><li>这相当于给插值过程加了一个约束：<strong>“中间补出来的东西，必须看起来像是一团连续的物质，而不能是杂乱的噪点。”</strong></li></ul><h3 id="总结：为什么-3DGS-更强？"><a href="#总结：为什么-3DGS-更强？" class="headerlink" title="总结：为什么 3DGS 更强？"></a>总结：为什么 3DGS 更强？</h3><table><thead><tr><th align="left">对比维度</th><th align="left">线性插值 (Linear Interpolation)</th><th align="left">3DGS &#x2F; MedGS</th></tr></thead><tbody><tr><td align="left"><strong>处理逻辑</strong></td><td align="left">纯数学计算，像素对像素混合</td><td align="left">几何拟合，用 3D 形状去逼近数据</td></tr><tr><td align="left"><strong>斜向物体</strong></td><td align="left">产生重影 (Ghosting)，结构断裂</td><td align="left"><strong>自动对齐</strong>，保持管状&#x2F;块状连续性</td></tr><tr><td align="left"><strong>层间空隙</strong></td><td align="left">模糊过渡，丢失细节</td><td align="left"><strong>利用椭球体积填充</strong>，保持边缘清晰</td></tr><tr><td align="left"><strong>数据依赖</strong></td><td align="left">极度依赖采样率，层距大就完蛋</td><td align="left">对稀疏数据鲁棒性更强（能脑补）</td></tr></tbody></table><p><strong>结论：</strong><br>如果你的 MRI 切片非常密集（比如 z 轴分辨率极高），线性插值够快也够用。<br>但正如你所说，只有 <strong>20 张切片</strong>（稀疏数据），线性插值会导致严重的<strong>层间断裂</strong>和<strong>阶梯效应</strong>。这时候，3DGS 利用其<strong>几何连续性</strong>的特性，能“猜”出比线性插值更符合人体生理结构的中间层。</p><p>它不是在瞎猜，它是假设“人体是连续的 3D 实体”来进行拟合，这在医学上是一个非常合理的假设。</p>]]></content>
    
    
    
    <tags>
      
      <tag>vegas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3dgs的技术原理</title>
    <link href="/2025/11/19/3dgs%E9%9A%8F%E6%83%B3/"/>
    <url>/2025/11/19/3dgs%E9%9A%8F%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<p><strong>3D Gaussian Splatting (3DGS)</strong> 是近年来计算机图形学和计算机视觉领域的一项突破性技术。它结合了显式几何表示（点云&#x2F;粒子）和体积渲染的优点，实现了<strong>实时的渲染速度</strong>和<strong>照片级的重建质量</strong>。</p><p>下面我将分两部分为你详细拆解：3DGS的<strong>训练与渲染流程</strong>，以及<strong>3D重建的深层意义</strong>。</p><hr><h3 id="第一部分：3DGS-的技术原理"><a href="#第一部分：3DGS-的技术原理" class="headerlink" title="第一部分：3DGS 的技术原理"></a>第一部分：3DGS 的技术原理</h3><p>简单来说，3DGS 不使用网格（Mesh）或神经网络（如 NeRF 中的 MLP）来表示物体，而是使用成千上万个<strong>3D 高斯椭球（3D Gaussians）</strong>。你可以把它们想象成无数个<strong>半透明的发光小云团</strong>，它们叠加在一起就组成了物体。</p><h4 id="1-渲染过程-Rendering-Process-前向传播"><a href="#1-渲染过程-Rendering-Process-前向传播" class="headerlink" title="1. 渲染过程 (Rendering Process) - 前向传播"></a>1. 渲染过程 (Rendering Process) - 前向传播</h4><p>这是展示结果的过程，也是训练中计算 Loss 的基础。3DGS 的渲染速度之所以极快（100+ FPS），是因为它采用了类似传统图形学的**光栅化（Rasterization）**管线。</p><ul><li><strong>输入：</strong> 一组 3D 高斯球。每个球包含属性：<ul><li><strong>位置 (Position):</strong> $x, y, z$</li><li><strong>形状 (Covariance):</strong> 由缩放 (Scale) 和旋转 (Rotation&#x2F;Quaternion) 决定。</li><li><strong>颜色 (Color):</strong> 使用球谐函数 (Spherical Harmonics) 表示，支持随视角变化的反射光泽。</li><li><strong>不透明度 (Opacity):</strong> $\alpha$，决定这个球有多“实”。</li></ul></li><li><strong>步骤 1：投影 (Projection)</strong><ul><li>将 3D 空间中的椭球投影到 2D 屏幕（摄像机平面）。</li><li>这个过程就像把一个气球压扁在纸上，3D 椭球变成了 2D 平面上的高斯分布（类似于一个模糊的圆斑）。</li></ul></li><li><strong>步骤 2：排序 (Sorting)</strong><ul><li><strong>关键步骤</strong>：将屏幕上所有的 2D 高斯斑点按照<strong>深度</strong>（离摄像机的距离）进行排序。通常是从远到近（Back-to-Front）。</li><li>3DGS 使用了非常高效的 GPU 基数排序（Radix Sort）。</li></ul></li><li><strong>步骤 3：基于图块的光栅化 (Tile-based Rasterization)</strong><ul><li>为了并行加速，屏幕被划分成 $16 \times 16$ 的小方块（Tiles）。</li><li>对每个像素，按顺序叠加高斯斑点的颜色。使用<strong>Alpha Blending</strong> 公式：<br>$$C &#x3D; \sum_{i} c_i \alpha_i T_i$$<br>（$T_i$ 代表前面所有层剩余的透明度，即“还没被挡住的光”）。</li><li>当不透明度累积到饱和（完全不透光）时，该像素停止计算，节省资源。</li></ul></li></ul><h4 id="2-训练过程-Training-Process-优化与自适应"><a href="#2-训练过程-Training-Process-优化与自适应" class="headerlink" title="2. 训练过程 (Training Process) - 优化与自适应"></a>2. 训练过程 (Training Process) - 优化与自适应</h4><p>训练的目标是：调整这几百万个高斯球的属性，使得它们渲染出来的图和真实照片一模一样。</p><ul><li><strong>初始化 (Initialization):</strong><ul><li>通常从<strong>稀疏点云</strong>（SfM，如 COLMAP 生成的点）开始。每个点初始化为一个小的 3D 高斯球。</li></ul></li><li><strong>迭代优化循环 (Optimization Loop):</strong><ol><li><strong>渲染</strong>：从当前视角渲染图像。</li><li><strong>计算 Loss</strong>：对比渲染图和真实照片（L1 Loss + D-SSIM），计算误差。</li><li><strong>反向传播 (Backpropagation)</strong>：计算梯度，更新每个高斯球的位置、形状、颜色和不透明度。</li></ol></li><li><strong>自适应密度控制 (Adaptive Density Control) - 3DGS 的核心魔法:</strong><br>单纯的梯度下降是不够的，3DGS 会动态地<strong>增加</strong>或<strong>删除</strong>高斯球：<ul><li><strong>克隆 (Clone):</strong> 如果一个高斯球很小，但梯度很大（说明这里细节不够），就把它复制一份，填补空缺（用于填充细节）。</li><li><strong>分裂 (Split):</strong> 如果一个高斯球很大，且梯度很大（说明它试图覆盖形状复杂的区域，导致甚至出现了伪影），就把它切分成两个小球（用于精细化几何）。</li><li><strong>剪枝 (Prune):</strong> 如果一个高斯球的不透明度 $\alpha$ 变得非常低（几乎透明），或者形状变得极其巨大&#x2F;极其细长（异常值），直接删除。</li></ul></li><li><strong>结果：</strong> 经过几万次迭代，从最初稀疏的点云，演变成数百万个精细分布的高斯球，完美拟合场景。</li></ul><hr><h3 id="第二部分：如何理解-3D-重建的意义"><a href="#第二部分：如何理解-3D-重建的意义" class="headerlink" title="第二部分：如何理解 3D 重建的意义"></a>第二部分：如何理解 3D 重建的意义</h3><p>3D 重建（3D Reconstruction）不仅仅是“把照片变成模型”，它是<strong>连接物理世界与数字世界的桥梁</strong>。我们可以从以下四个维度来理解它的意义：</p><h4 id="1-数字化存档与文化传承-Preservation"><a href="#1-数字化存档与文化传承-Preservation" class="headerlink" title="1. 数字化存档与文化传承 (Preservation)"></a>1. 数字化存档与文化传承 (Preservation)</h4><ul><li><strong>超越照片的维度：</strong> 照片是二维的切片，丢失了深度和空间感。3D 重建是对物理空间的完整“克隆”。</li><li><strong>应用：</strong> 巴黎圣母院大火后，正是依靠之前的激光扫描和 3D 重建数据，修复工作才有了精确的蓝图。文物的数字化让后人即使在实物损毁后，也能在数字世界永恒地观察其细节。</li></ul><h4 id="2-沉浸式交互的基石-Interaction-Spatial-Computing"><a href="#2-沉浸式交互的基石-Interaction-Spatial-Computing" class="headerlink" title="2. 沉浸式交互的基石 (Interaction &amp; Spatial Computing)"></a>2. 沉浸式交互的基石 (Interaction &amp; Spatial Computing)</h4><ul><li><strong>6DoF (六自由度) 体验：</strong> 看视频是被动的（摄像机怎么动你就怎么看）。但有了 3D 重建，用户可以在场景中自由行走（VR&#x2F;AR）。</li><li><strong>空间计算时代：</strong> 随着 Apple Vision Pro 等设备的出现，屏幕不再局限于显示器，而是整个空间。3DGS 这种技术让<strong>把现实世界搬进头显</strong>成为可能，实现了远程旅游、远程看房的真实感（Telepresence）。</li></ul><h4 id="3-机器感知与人工智能-AI-Robotics"><a href="#3-机器感知与人工智能-AI-Robotics" class="headerlink" title="3. 机器感知与人工智能 (AI &amp; Robotics)"></a>3. 机器感知与人工智能 (AI &amp; Robotics)</h4><ul><li><strong>机器的眼睛：</strong> 自动驾驶汽车和机器人不仅需要看到“图片”，更需要理解“空间”。</li><li><strong>SLAM 与 导航：</strong> 3D 重建帮助机器人理解“我在哪里”、“前面有什么障碍物”、“这个物体的形状是什么”。</li><li><strong>具身智能 (Embodied AI)：</strong> 如果我们要训练一个机器人去拿杯子，它必须在一个物理准确的 3D 环境中模拟训练。3DGS 可以快速构建这种高保真的模拟环境。</li></ul><h4 id="4-内容创作的民主化-Democratization-of-Creation"><a href="#4-内容创作的民主化-Democratization-of-Creation" class="headerlink" title="4. 内容创作的民主化 (Democratization of Creation)"></a>4. 内容创作的民主化 (Democratization of Creation)</h4><ul><li><strong>降低门槛：</strong> 以前做 3D 场景需要专业的建模师用 Maya&#x2F;Blender 耗时数周。</li><li><strong>AIGC 3D：</strong> 现在的技术（如 3DGS）允许普通人用手机拍一段视频，几分钟内就生成电影级的 3D 场景。这极大地解放了游戏开发、电影特效（VFX）和元宇宙内容的生产力。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>3DGS</strong> 是一种<strong>显式、高效、可微</strong>的渲染技术，它通过“泼溅”数百万个微小的椭球来欺骗我们的眼睛，让我们看到连续的物体。</p><p>而 <strong>3D 重建</strong> 的意义在于**“空间化”**信息。它将人类对世界的感知从 2D 图像升级为 3D 空间，不仅让人类能更真实地回溯记忆，也让 AI 能够真正地理解和操作物理世界。</p>]]></content>
    
    
    
    <tags>
      
      <tag>3dgs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇文章</title>
    <link href="/2025/11/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <url>/2025/11/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>荒废了好久的博客，最近才开始重新写。</p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>next</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/11/19/hello-world/"/>
    <url>/2025/11/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
